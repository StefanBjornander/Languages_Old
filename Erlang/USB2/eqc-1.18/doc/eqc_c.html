<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module eqc_c</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module eqc_c</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>
   Functions for interfacing with C code.
<p>Copyright © 2009 QuviQ</p>

<p><b>Authors:</b> Ulf Norell (<a href="mailto:ulf.norell@quviq.com"><tt>ulf.norell@quviq.com</tt></a>).</p>

<h2><a name="description">Description</a></h2>
   Functions for interfacing with C code.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-ptr">ptr()</a></h3>
<p><tt>ptr() = {ptr, <a href="#type-type">type()</a>, integer()}</tt></p>
<p>Pointer values are tagged with their types.</p>

<h3 class="typedecl"><a name="type-ptr_type">ptr_type()</a></h3>
<p><tt>ptr_type() = T | void | {func, T, [T]}</tt>
<ul class="definitions"><li><tt>T = <a href="#type-type">type()</a></tt></li>
</ul></p>
<p>Types that can appear as the target of a pointer.</p>

<h3 class="typedecl"><a name="type-type">type()</a></h3>
<p><tt>type() = char | unsigned_char | short | int | float | double | {ptr, P} | {struct, StructName} | DefinedName</tt>
<ul class="definitions"><li><tt>P = <a href="#type-ptr_type">ptr_type()</a></tt></li>
<li><tt>T = <a href="#type-type">type()</a></tt></li>
<li><tt>StructName = atom()</tt></li>
<li><tt>DefinedName = string()</tt></li>
</ul></p>
<p>Currently supported C types. Defined names are types introduced by
   typedefs.</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_to_ptr-2">add_to_ptr/2</a></td><td>Add N to a pointer.</td></tr>
<tr><td valign="top"><a href="#alloc-2">alloc/2</a></td><td>Allocate memory for an object of type <code>Type</code> and initialize it to
      the value <code>X</code>.</td></tr>
<tr><td valign="top"><a href="#array_index-2">array_index/2</a></td><td>Return the value at the given index of an array.</td></tr>
<tr><td valign="top"><a href="#array_index-3">array_index/3</a></td><td>Set the value at the given index of an array.</td></tr>
<tr><td valign="top"><a href="#cast_ptr-2">cast_ptr/2</a></td><td>Change the type of a pointer.</td></tr>
<tr><td valign="top"><a href="#create_array-2">create_array/2</a></td><td>Allocate an array of the given type containing the values <code>Xs</code>.</td></tr>
<tr><td valign="top"><a href="#create_string-1">create_string/1</a></td><td> Allocate a C string containing the given string.</td></tr>
<tr><td valign="top"><a href="#deref-1">deref/1</a></td><td>Dereference a pointer.</td></tr>
<tr><td valign="top"><a href="#free-1">free/1</a></td><td>Free the memory pointed to by a pointer.</td></tr>
<tr><td valign="top"><a href="#read_array-2">read_array/2</a></td><td>Read the elements of an array.</td></tr>
<tr><td valign="top"><a href="#read_string-1">read_string/1</a></td><td>Read the value of a null terminated C string.</td></tr>
<tr><td valign="top"><a href="#restart-0">restart/0</a></td><td>Restart the C program.</td></tr>
<tr><td valign="top"><a href="#set_timeout-1">set_timeout/1</a></td><td>Set the timeout for external C calls.</td></tr>
<tr><td valign="top"><a href="#sizeof-1">sizeof/1</a></td><td>The size in bytes required to store an object of the given type.</td></tr>
<tr><td valign="top"><a href="#start-1">start/1</a></td><td>Equivalent to <a href="#start-2"><tt>start(Module, atom_to_list(Module) ++ ".c")</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#start-2">start/2</a></td><td>Equivalent to <a href="#start-3"><tt>start(Module, File,
      [{cflags, "-lpthread"}, definitions_only])</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#start-3">start/3</a></td><td>Generates and loads an Erlang wrapper <code>Module</code> for the C file <code>File</code>.</td></tr>
<tr><td valign="top"><a href="#stop-0">stop/0</a></td><td>Stop the C program.</td></tr>
<tr><td valign="top"><a href="#store-2">store/2</a></td><td>Store a value at the location pointed to by a pointer.</td></tr>
<tr><td valign="top"><a href="#store_array-2">store_array/2</a></td><td>Store values in the array pointed to be the first argument.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="add_to_ptr-2">add_to_ptr/2</a></h3>
<div class="spec">
<p><tt>add_to_ptr(Ptr, N) -&gt; any()</tt></p>
</div><p>Add N to a pointer. Equivalent to <code>Ptr += N</code> in C. In other words
      the value of the resulting pointer depends on the size of the type
      pointed to.</p>

<h3 class="function"><a name="alloc-2">alloc/2</a></h3>
<div class="spec">
<p><tt>alloc(Type::<a href="#type-type">type()</a>, X::term()) -&gt; <a href="#type-ptr">ptr()</a></tt></p>
</div><p>Allocate memory for an object of type <code>Type</code> and initialize it to
      the value <code>X</code>. Type checks the value before allocating the memory.</p>

<h3 class="function"><a name="array_index-2">array_index/2</a></h3>
<div class="spec">
<p><tt>array_index(Ptr::<a href="#type-ptr">ptr()</a>, Index::integer()) -&gt; term()</tt></p>
</div><p>Return the value at the given index of an array. Equivalent to
      the C code <code>Ptr[Index]</code>. Indexing starts at index 0.</p>

<h3 class="function"><a name="array_index-3">array_index/3</a></h3>
<div class="spec">
<p><tt>array_index(Ptr::<a href="#type-ptr">ptr()</a>, Index::integer(), Val::term()) -&gt; ok</tt></p>
</div><p>Set the value at the given index of an array. Equivalent to
      the C code <code>Ptr[Index] = Val</code>. Indexing starts at index 0.</p>

<h3 class="function"><a name="cast_ptr-2">cast_ptr/2</a></h3>
<div class="spec">
<p><tt>cast_ptr(Type::<a href="#type-type">type()</a>, Ptr::<a href="#type-ptr">ptr()</a>) -&gt; <a href="#type-ptr">ptr()</a></tt></p>
</div><p>Change the type of a pointer. Use with care.
      Equivalent to the C code <code>(Type *)Ptr</code>.</p>

<h3 class="function"><a name="create_array-2">create_array/2</a></h3>
<div class="spec">
<p><tt>create_array(Type::<a href="#type-type">type()</a>, Xs::[term()]) -&gt; <a href="#type-ptr">ptr()</a></tt></p>
</div><p>Allocate an array of the given type containing the values <code>Xs</code>.
      The values are type checked before allocation.</p>

<h3 class="function"><a name="create_string-1">create_string/1</a></h3>
<div class="spec">
<p><tt>create_string(S::string()) -&gt; <a href="#type-ptr">ptr()</a></tt></p>
</div><p> Allocate a C string containing the given string.</p>

<h3 class="function"><a name="deref-1">deref/1</a></h3>
<div class="spec">
<p><tt>deref(Ptr::<a href="#type-ptr">ptr()</a>) -&gt; term()</tt></p>
</div><p>Dereference a pointer.</p>

<h3 class="function"><a name="free-1">free/1</a></h3>
<div class="spec">
<p><tt>free(Ptr::<a href="#type-ptr">ptr()</a>) -&gt; ok</tt></p>
</div><p>Free the memory pointed to by a pointer. Equivalent to the
      C code <code>free(Ptr)</code>.</p>

<h3 class="function"><a name="read_array-2">read_array/2</a></h3>
<div class="spec">
<p><tt>read_array(Ptr::<a href="#type-ptr">ptr()</a>, N::integer()) -&gt; [term()]</tt></p>
</div><p>Read the elements of an array. Since C arrays do not store their length,
      the length has to be supplied separately.</p>

<h3 class="function"><a name="read_string-1">read_string/1</a></h3>
<div class="spec">
<p><tt>read_string(Ptr::<a href="#type-ptr">ptr()</a>) -&gt; string()</tt></p>
</div><p>Read the value of a null terminated C string.</p>

<h3 class="function"><a name="restart-0">restart/0</a></h3>
<div class="spec">
<p><tt>restart() -&gt; any()</tt></p>
</div><p>Restart the C program. Just restarts the executable, no recompilation is
      performed.</p>

<h3 class="function"><a name="set_timeout-1">set_timeout/1</a></h3>
<div class="spec">
<p><tt>set_timeout(N) -&gt; any()</tt></p>
</div><p>Set the timeout for external C calls. Can also be set from <code>start/3</code>.</p>

<h3 class="function"><a name="sizeof-1">sizeof/1</a></h3>
<div class="spec">
<p><tt>sizeof(Type::<a href="#type-type">type()</a>) -&gt; integer()</tt></p>
</div><p>The size in bytes required to store an object of the given type.</p>

<h3 class="function"><a name="start-1">start/1</a></h3>
<div class="spec">
<p><tt>start(Module) -&gt; any()</tt></p>
</div><p>Equivalent to <a href="#start-2"><tt>start(Module, atom_to_list(Module) ++ ".c")</tt></a>.</p>


<h3 class="function"><a name="start-2">start/2</a></h3>
<div class="spec">
<p><tt>start(Module, File) -&gt; any()</tt></p>
</div><p>Equivalent to <a href="#start-3"><tt>start(Module, File,
      [{cflags, "-lpthread"}, definitions_only])</tt></a>.</p>


<h3 class="function"><a name="start-3">start/3</a></h3>
<div class="spec">
<p><tt>start(Module::atom(), File::string(), Options::<a href="#type-proplist">proplist()</a>) -&gt; ok | failed</tt></p>
</div><p><p>Generates and loads an Erlang wrapper <code>Module</code> for the C file <code>File</code>.
      For instance, if <code>foo.c</code> defines a function
      <code>int plus(int x, int y)</code>, calling <code>eqc_c:start(foo, "foo.c", [])</code>
      allows <code>plus</code> to be called as <code>foo:plus(1, 2)</code>.</p>

      Interface generation options:
      <dl>
       <dt><code>definitions_only</code></dt>
       <dd>Only generate wrappers for function definitions (and not function prototypes).</dd>
       <dt><code>{exclude_functions, [atom() | string()]}</code></dt>
       <dd>Do not generate wrappers for the specified functions.</dd>
       <dt><code>{include_functions, [atom() | string()]}</code></dt>
       <dd>Only generate wrappers for the specified functions.</dd>
      </dl>
      Runtime options:
      <dl>
       <dt><code>{timeout, integer()}</code></dt>
       <dd>Specify the timeout for C function calls (default 500 ms).</dd>
      </dl>
      C compiler options:
      <dl>
       <dt><code>{cc, string()}</code></dt>
       <dd>Specifies how to call the C compiler.</dd>
       <dt><code>{cpp, string()}</code></dt>
       <dd>Specifies how to call the C preprocessor.</dd>
       <dt><code>{cflags, string()}</code></dt>
       <dd>Additional flags to the C compiler.</dd>
       <dt><code>{cppflags, string()}</code></dt>
       <dd>Additional flags to the C preprocessor.</dd>
       <dt><code>{executable, string()}</code></dt>
       <dd>Specifies the name of the generated executable.</dd>
       <dt><code>{c_wrapper, string()}</code></dt>
       <dd>Specifies the filename of the generated C wrapper code.</dd>
       <dt><code>{wrapper_lib, string()}</code></dt>
       <dd>Specifies the location of the C wrapper library.</dd>
      </dl></p>

<h3 class="function"><a name="stop-0">stop/0</a></h3>
<div class="spec">
<p><tt>stop() -&gt; any()</tt></p>
</div><p>Stop the C program.</p>

<h3 class="function"><a name="store-2">store/2</a></h3>
<div class="spec">
<p><tt>store(Ptr::<a href="#type-ptr">ptr()</a>, Val::term()) -&gt; ok</tt></p>
</div><p>Store a value at the location pointed to by a pointer. Equivalent to
      the C code <code>*Ptr = Val</code>. The value is type checked against the
      type of the pointer.</p>

<h3 class="function"><a name="store_array-2">store_array/2</a></h3>
<div class="spec">
<p><tt>store_array(Ptr::<a href="#type-ptr">ptr()</a>, List::term()) -&gt; ok</tt></p>
</div><p>Store values in the array pointed to be the first argument.
      The values are type checked against the type of the pointer.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Sep 22 2009, 19:50:59.</i></p>
</body>
</html>
