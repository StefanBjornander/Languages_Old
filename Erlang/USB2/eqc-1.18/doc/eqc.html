<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module eqc</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module eqc</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>This module defines functions for writing and testing QuickCheck properties.

<p><b>Version:</b> 1.18</p>

<h2><a name="description">Description</a></h2>This module defines functions for writing and testing QuickCheck properties.
 Much of the interface is provided via macros (defined in <tt>eqc.hrl</tt>).
 These are documented below:
 <h2><tt>?FORALL(X,Gen,Prop)</tt></h2>
 Property that holds if <tt>Prop</tt> holds for all values <tt>X</tt> that
 can be generated by <tt>Gen</tt>. For example,
 <pre>
 prop_reverse() -&gt;
   ?FORALL(Xs,list(int()),
      lists:reverse(lists:reverse(Xs)) == Xs).
 </pre>
 Generators are defined using the module <a href="eqc_gen.html"><code>eqc_gen</code></a>.
 <h2><tt>?IMPLIES(Pre,Prop)</tt></h2>
 Property that holds if <tt>Prop</tt> holds whenever the precondition
 <tt>Pre</tt> is true. The precondition must be a boolean, but <tt>Prop</tt>
 can be any QuickCheck property. An implication is tested by discarding test
 cases which do not satisfy the precondition. This can make testing slow,
 since many more test cases may need to be generated to find 100 which
 satisfy the precondition. In the worst case, QuickCheck may not be able
 to find enough test cases that do satisfy the precondition, in which case
 the number actually found is reported. Some preconditions may also skew
 the test data badly--for example, a precondition that a list is sorted
 skews the test data towards short lists, since random longer lists are
 extremely unlikely to be sorted just by chance. <tt>?IMPLIES</tt> works
 well for preconditions which are true with a high probability, but if the
 precondition is unlikely to hold, then it is better to write a custom
 generator which generates test cases where the precondition is true.
 <h2><tt>?WHENFAIL(Action,Prop)</tt></h2>
 Property that is equivalent to <tt>Prop</tt>, but performs <tt>Action</tt>
 (for its side effects) when <tt>Prop</tt> fails. This can be used to
 print additional information when a test case fails.
 <h2><tt>?TRAPEXIT(Prop)</tt></h2>
 A property which tests <tt>Prop</tt> in a separate process, trapping
 exits and treating them as test failures. QuickCheck always catches
 locally raised exceptions in properties, but when a test exits because
 a linked process fails, then the exit is NOT caught unless the body of
 the property is enclosed in ?TRAPEXIT. Shrinking is disabled
 for any ?FORALLs enclosed by ?TRAPEXIT (although not, of course, for
 ?FORALLs which enclose it). Thus ?TRAPEXIT would typically be
 used inside the innermost ?FORALL of a property.
 <h2><tt>?ALWAYS(N,Prop)</tt></h2>
 A property which tests <tt>Prop</tt> repeatedly <tt>N</tt> times, failing
 as soon as any of the tests of <tt>Prop</tt> fails. Typically this is used
 as follows:
 <pre>?FORALL(X,...,?ALWAYS(N,?FORALL(Y,...,...)))</pre>
 which generates <tt>N</tt> values of <tt>Y</tt> for each value of <tt>X</tt>.
 This is useful if
 <ul>
 <li>Generating <tt>X</tt>, or changing <tt>X</tt> from test to
 test, is expensive--for example, if <tt>X</tt> is a configuration which
 is expensive to install, so that we want to run many tests for each
 configuration.
 </li>
 <li>
 We are trying to shrink <tt>X</tt>, but <tt>Y</tt> is generated from
 <tt>X</tt>, and most choices of <tt>Y</tt> make the test pass. In
 this situation, then shrinking is likely to fail, because whenever
 we try to shrink <tt>X</tt> to a smaller value, then we are likely
 to choose a <tt>Y</tt> that happens to make the test pass. Trying
 many values of <tt>Y</tt> makes it much more likely that one of them will
 fail, and so shrinking will succeed.
 </li>
 </ul>
 Don't use this macro at the top-level of a property: <a href="#numtests-2"><code>numtests/2</code></a> is more appropriate for this.
 <h2><tt>?SOMETIMES(N,Prop)</tt></h2>
 A property which tests <tt>Prop</tt> repeatedly <tt>N</tt> times,
 failing only if <i>all</i> of the tests fail. In other words, the
 property passes if <tt>Prop</tt> <i>sometimes</i> passes. This is
 used in situations where test outcomes are non-deterministic, to
 search for test cases that <i>consistently</i> fail. A property such
 as <tt>?FORALL(X,...,?SOMETIMES(10,...))</tt> will find test cases
 <tt>X</tt> for which the property inside <tt>?SOMETIMES</tt> is very
 likely to fail.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-counterexample">counterexample()</a></h3>
<p><b>abstract datatype</b>: <tt>counterexample()</tt></p>
<p>A counter-example to a QuickCheck property, which can be obtained
 using  <a href="#counterexample-0"><code>counterexample/0</code></a> or <a href="#counterexample-1"><code>counterexample/1</code></a>, and used to repeat a test,
 or test a different property in the same case. Counterexamples are represented by the values
 bound by ?FORALL--for the counterexample to make sense independently, it's important that
 these were generated without side-effects.</p>

<h3 class="typedecl"><a name="type-property">property()</a></h3>
<p><b>abstract datatype</b>: <tt>property()</tt></p>
<p>QuickCheck properties, which can either be boolean
 expressions, or constructed using the functions in this module.
 QuickCheck properties are tested using <a href="#quickcheck-1"><code>quickcheck/1</code></a>.</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#active_users-0">active_users/0</a></td><td>Fetch a list of the currently active users of your licence.</td></tr>
<tr><td valign="top"><a href="#aggregate-2">aggregate/2</a></td><td>Like <a href="#collect-2"><code>collect/2</code></a>, but collects a <i>list</i> of values from
 each test, rather than just one.</td></tr>
<tr><td valign="top"><a href="#authenticate-1">authenticate/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#backtrace-0">backtrace/0</a></td><td>Displays a stack backtrace from the last exception QuickCheck caught.</td></tr>
<tr><td valign="top"><a href="#check-2">check/2</a></td><td>Tests the property in the case given.</td></tr>
<tr><td valign="top"><a href="#classify-3">classify/3</a></td><td>Property which is logically equivalent to <tt>Prop</tt>, but also
 classifies test cases and displays the distribution of test case classes
 when testing is complete.</td></tr>
<tr><td valign="top"><a href="#collect-2">collect/2</a></td><td>Equivalent to <a href="#classify-3"><tt>classify(true, S, Prop)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#counterexample-0">counterexample/0</a></td><td>Returns the last counter-example found.</td></tr>
<tr><td valign="top"><a href="#counterexample-1">counterexample/1</a></td><td>Tests the property in the same was as <a href="#quickcheck-1"><code>quickcheck/1</code></a>, but if
 a test fails, then the failing test case is returned as a counterexample.</td></tr>
<tr><td valign="top"><a href="#counterexample-2">counterexample/2</a></td><td>Nearly equivalent to counterexample(M:P())
 (but see <a href="#recheck-1"><code>recheck/1</code></a>).</td></tr>
<tr><td valign="top"><a href="#counterexample-3">counterexample/3</a></td><td>Nearly equivalent to counterexample(apply(M,P,Xs))
 (but see <a href="#recheck-1"><code>recheck/1</code></a>).</td></tr>
<tr><td valign="top"><a href="#counterexamples-0">counterexamples/0</a></td><td>Returns a list of the counterexamples found by the last call
  of <code>eqc:module</code>, paired with the name of the property that failed.</td></tr>
<tr><td valign="top"><a href="#fails-1">fails/1</a></td><td>A property which succeeds when its argument fails.</td></tr>
<tr><td valign="top"><a href="#force_start-0">force_start/0</a></td><td>Equivalent to <a href="#start-0"><tt>start()</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#measure-3">measure/3</a></td><td>Collects the values of X while testing Prop, and if all tests
 pass, displays statistics such as the minimum, average, and maximum
 values, identified by the name Name.</td></tr>
<tr><td valign="top"><a href="#module-1">module/1</a></td><td>Tests all the properties exported from a module, given the module name.</td></tr>
<tr><td valign="top"><a href="#numtests-2">numtests/2</a></td><td>Property which is logically equivalent to <tt>Prop</tt>, but is
 tested <tt>N</tt> times rather than 100.</td></tr>
<tr><td valign="top"><a href="#quickcheck-1">quickcheck/1</a></td><td>Tests the property in 100 random cases, printing a counter-example
 if one is found.</td></tr>
<tr><td valign="top"><a href="#quickcheck-2">quickcheck/2</a></td><td>Nearly equivalent to quickcheck(M:P())
 (but see <a href="#recheck-1"><code>recheck/1</code></a>).</td></tr>
<tr><td valign="top"><a href="#quickcheck-3">quickcheck/3</a></td><td>Nearly equivalent to quickcheck(apply(M,P,Xs))
 (but see <a href="#recheck-1"><code>recheck/1</code></a>).</td></tr>
<tr><td valign="top"><a href="#recheck-0">recheck/0</a></td><td>Equivalent to <a href="#recheck-1"><tt>recheck(1)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#recheck-1">recheck/1</a></td><td>Repeat the Nth-most-recent failed test, where N&gt;=1 and recheck(1) repeats the most
 recent failure, so that (for example) tests can be repeated with tracing turned on.</td></tr>
<tr><td valign="top"><a href="#registration-1">registration/1</a></td><td>Create a QuickCheck licence for the current user, using a
 one-time registration identifier.</td></tr>
<tr><td valign="top"><a href="#reserve-1">reserve/1</a></td><td>Reserve a QuickCheck licence for this machine.</td></tr>
<tr><td valign="top"><a href="#reserved_until-0">reserved_until/0</a></td><td>The local time that the currently active QuickCheck licence is
 reserved until.</td></tr>
<tr><td valign="top"><a href="#start-0">start/0</a></td><td>Equivalent to <a href="#start-1"><tt>start(true)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#start-1">start/1</a></td><td>Starts the QuickCheck server.</td></tr>
<tr><td valign="top"><a href="#stop-0">stop/0</a></td><td>Stops the QuickCheck server.</td></tr>
<tr><td valign="top"><a href="#unlock_licence-0">unlock_licence/0</a></td><td>Unlock the Quviq licence files.</td></tr>
<tr><td valign="top"><a href="#version-0">version/0</a></td><td>Returns the version number of this version of QuickCheck.</td></tr>
<tr><td valign="top"><a href="#watch_shrinking-0">watch_shrinking/0</a></td><td>Equivalent to <a href="#watch_shrinking-1"><tt>watch_shrinking(1)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#watch_shrinking-1">watch_shrinking/1</a></td><td>Repeats the N-th most recent failed test, like <a href="#recheck-1"><code>recheck/1</code></a>, but displays <i>all</i>
 the test cases explored during shrinking.</td></tr>
<tr><td valign="top"><a href="#withseed-2">withseed/2</a></td><td>(<em>Deprecated</em>.) Run a test case with a given seed.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="active_users-0">active_users/0</a></h3>
<div class="spec">
<p><tt>active_users() -&gt; any()</tt></p>
</div><p>Fetch a list of the currently active users of your licence. The
 users are sorted by the expiry times of their current sessions; thus
 the user whose licence may first become free is first in the
 list. Of course, other users who continue running QuickCheck will
 automatically extend their sessions, so there is no guarantee that a
 licence will actually be released at the time indicated.</p>

<h3 class="function"><a name="aggregate-2">aggregate/2</a></h3>
<div class="spec">
<p><tt>aggregate(L::list(term()), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt></p>
</div><p>Like <a href="#collect-2"><code>collect/2</code></a>, but collects a <i>list</i> of values from
 each test, rather than just one. The lists from each test are aggregated,
 and the statistics displayed show how often each list element occurred in
 the aggregated data.
 <p>
 A typical use would be to aggregate the list of command names generated
 by <a href="eqc_statem.html#commands-1"><code>eqc_statem:commands/1</code></a>, in order to see how often each individual
 command appeared in generated tests:
 <pre>aggregate([F || {set,_,{call,_,F,_}} &lt;- Cmds], ...) </pre>
 </p></p>

<h3 class="function"><a name="authenticate-1">authenticate/1</a></h3>
<div class="spec">
<p><tt>authenticate(Crypt) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="backtrace-0">backtrace/0</a></h3>
<div class="spec">
<p><tt>backtrace() -&gt; ok</tt></p>
</div><p>Displays a stack backtrace from the last exception QuickCheck caught. Note that
 this is only possible if the exception is raised in the process in which the test
 case starts. If a test case fails because of an exception in another, linked,
 process, then no backtrace is available. Calls to functions in the implementation
 of QuickCheck itself are not included in the backtrace.
 <p>If you really need to see a backtrace from a linked process, then you can do so by
 catching
 the exception yourself in that process, using erlang:get_stacktrace() to obtain the
 backtrace, and printing it yourself.</p></p>

<h3 class="function"><a name="check-2">check/2</a></h3>
<div class="spec">
<p><tt>check(P::<a href="#type-property">property()</a>, Values::<a href="#type-counterexample">counterexample()</a>) -&gt; bool()</tt></p>
</div><p>Tests the property in the case given. Counterexamples are generated by testing a
 property using <a href="#counterexample-1"><code>counterexample/1</code></a> or <a href="#counterexample-0"><code>counterexample/0</code></a>, and contain a list
 of the values bound by ?FORALL. A property tested by check should begin with the <i>same</i>
 sequence of ?FORALL s as the property from which the counterexample was generated, otherwise
 the results will be unpredictable. In particular, there is no check that the values
 in the counterexample could actually have been generated by the ?FORALL s in the property under
 test.
 <p><a href="#check-2"><code>check/2</code></a> can be used without a QuickCheck licence, allowing anyone to run
 tests that a licenced user has generated.</p></p>

<h3 class="function"><a name="classify-3">classify/3</a></h3>
<div class="spec">
<p><tt>classify(B::bool(), S::term(), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt></p>
</div><p>Property which is logically equivalent to <tt>Prop</tt>, but also
 classifies test cases and displays the distribution of test case classes
 when testing is complete. If the boolean is true then the current test case is
 labelled with the term <tt>S</tt>,
 and, after testing is complete, QuickCheck prints out the percentage of
 test cases carrying each label. This can be used to check that the space
 of possible test cases has been covered reasonably well. For example,
 classifying test cases according to the length of a list enables one to
 see whether unreasonably many lists were short. Classifying
 test cases is a way to discover skewed distributions, such as can arise
 from using <tt>?IMPLIES</tt>. It is good practice to check the distribution
 of test data using <tt>classify</tt> or <a href="#collect-2"><code>collect/2</code></a>, at least while
 properties are being developed.
 <p>
 Each test case can be labelled with any number of labels: QuickCheck then
 displays the percentage of each label in the generated
 test data.
 </p>
 <p>
 Calls of classify or collect can be nested, in which case each call
 generates its own table of distributions.
 </p></p>

<h3 class="function"><a name="collect-2">collect/2</a></h3>
<div class="spec">
<p><tt>collect(S::term(), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt></p>
</div><p>Equivalent to <a href="#classify-3"><tt>classify(true, S, Prop)</tt></a>.</p>


<h3 class="function"><a name="counterexample-0">counterexample/0</a></h3>
<div class="spec">
<p><tt>counterexample() -&gt; true | <a href="#type-counterexample">counterexample()</a></tt></p>
</div><p>Returns the last counter-example found. See <a href="#counterexample-1"><code>counterexample/1</code></a>.</p>

<h3 class="function"><a name="counterexample-1">counterexample/1</a></h3>
<div class="spec">
<p><tt>counterexample(P::<a href="#type-property">property()</a>) -&gt; true | <a href="#type-counterexample">counterexample()</a></tt></p>
</div><p>Tests the property in the same was as <a href="#quickcheck-1"><code>quickcheck/1</code></a>, but if
 a test fails, then the failing test case is returned as a counterexample.</p>

<h3 class="function"><a name="counterexample-2">counterexample/2</a></h3>
<div class="spec">
<p><tt>counterexample(M, P) -&gt; any()</tt></p>
</div><p>Nearly equivalent to counterexample(M:P())
 (but see <a href="#recheck-1"><code>recheck/1</code></a>).</p>

<h3 class="function"><a name="counterexample-3">counterexample/3</a></h3>
<div class="spec">
<p><tt>counterexample(M, P, Xs) -&gt; any()</tt></p>
</div><p>Nearly equivalent to counterexample(apply(M,P,Xs))
 (but see <a href="#recheck-1"><code>recheck/1</code></a>).</p>

<h3 class="function"><a name="counterexamples-0">counterexamples/0</a></h3>
<div class="spec">
<p><tt>counterexamples() -&gt; list({atom(), <a href="#type-counterexample">counterexample()</a>})</tt></p>
</div><p>Returns a list of the counterexamples found by the last call
  of <code>eqc:module</code>, paired with the name of the property that failed.</p>

<h3 class="function"><a name="fails-1">fails/1</a></h3>
<div class="spec">
<p><tt>fails(P::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt></p>
</div><p>A property which succeeds when its argument fails.
 Sometimes it is useful to write down properties which do <i>not</i> hold
 (even though one might expect them to). This can help prevent misconceptions.
 <tt>fails(P)</tt> is tested in the same way as <tt>P</tt>, but
 fails only if <tt>P</tt> <i>succeeds</i> 100 times. Thus
 <tt>fails(P)</tt> declares that QuickCheck should be able to find
 a counter-example to property <tt>P</tt>.</p>

<h3 class="function"><a name="force_start-0">force_start/0</a></h3>
<div class="spec">
<p><tt>force_start() -&gt; any()</tt></p>
</div><p>Equivalent to <a href="#start-0"><tt>start()</tt></a>.</p>


<h3 class="function"><a name="measure-3">measure/3</a></h3>
<div class="spec">
<p><tt>measure(Name::atom() | string(), X::number() | list(number()), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt></p>
</div><p>Collects the values of X while testing Prop, and if all tests
 pass, displays statistics such as the minimum, average, and maximum
 values, identified by the name Name. X can also be a list of values,
 in which case all of them are included in the measurements.</p>

<h3 class="function"><a name="module-1">module/1</a></h3>
<div class="spec">
<p><tt>module(Mod::atom()) -&gt; list(atom())</tt></p>
</div><p>Tests all the properties exported from a module, given the module name.
 Any function with arity zero whose name begins with "prop_" is treated as a
 property. The result is a list of the names of the properties that failed.</p>

<h3 class="function"><a name="numtests-2">numtests/2</a></h3>
<div class="spec">
<p><tt>numtests(N::<a href="#type-int">int()</a>, Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt></p>
</div><p>Property which is logically equivalent to <tt>Prop</tt>, but is
 tested <tt>N</tt> times rather than 100. If numtests appears more than once
 in a property, then the outermost use takes precedence.</p>

<h3 class="function"><a name="quickcheck-1">quickcheck/1</a></h3>
<div class="spec">
<p><tt>quickcheck(P::<a href="#type-property">property()</a>) -&gt; bool()</tt></p>
</div><p>Tests the property in 100 random cases, printing a counter-example
 if one is found. Initially small test cases are generated, then the
 size increases as testing progresses (see <a href="eqc_gen.html"><code>eqc_gen</code></a>, <tt>?SIZED</tt>,
 <a href="eqc_gen.html#resize-2"><code>eqc_gen:resize/2</code></a> for the way size affects test data generation).
 The result is <tt>true</tt> if all tests succeeded (or if one failed,
 and failure was expected). On success, <tt>quickcheck</tt> analyses
 the distribution of test case labels. On failure, <tt>quickcheck</tt>
 tries to simplify the counter-example found as far as possible (see <i>
 shrinking</i>, described in <a href="eqc_gen.html"><code>eqc_gen</code></a>).</p>

<h3 class="function"><a name="quickcheck-2">quickcheck/2</a></h3>
<div class="spec">
<p><tt>quickcheck(M, P) -&gt; any()</tt></p>
</div><p>Nearly equivalent to quickcheck(M:P())
 (but see <a href="#recheck-1"><code>recheck/1</code></a>).</p>

<h3 class="function"><a name="quickcheck-3">quickcheck/3</a></h3>
<div class="spec">
<p><tt>quickcheck(M, P, Xs) -&gt; any()</tt></p>
</div><p>Nearly equivalent to quickcheck(apply(M,P,Xs))
 (but see <a href="#recheck-1"><code>recheck/1</code></a>).</p>

<h3 class="function"><a name="recheck-0">recheck/0</a></h3>
<div class="spec">
<p><tt>recheck() -&gt; bool()</tt></p>
</div><p>Equivalent to <a href="#recheck-1"><tt>recheck(1)</tt></a>.</p>


<h3 class="function"><a name="recheck-1">recheck/1</a></h3>
<div class="spec">
<p><tt>recheck(N::integer()) -&gt; bool()</tt></p>
</div><p>Repeat the Nth-most-recent failed test, where N&gt;=1 and recheck(1) repeats the most
 recent failure, so that (for example) tests can be repeated with tracing turned on.
 The result is true if the test now succeeds, if the test case is now
 excluded by a modified precondition, or if the test is now expected to fail
 (i.e. is defined using <a href="#fails-1"><code>fails/1</code></a>). Test cases
 are not saved as data, they are regenerated using the same random seed when the test is
 repeated. If the generators have been modifed in the meantime, or if the generators used
 have side effects, then the generated data may not be the same as before.
<p> The history of failed tests is collected by <a href="#quickcheck-1"><code>quickcheck/1</code></a>. Tests which were
 expected to fail (see <a href="#fails-1"><code>fails/1</code></a>) are not recorded in the history. The history is
 not affected by <a href="#recheck-1"><code>recheck/1</code></a> itself.</p>
 <p>A potential <b>gotcha</b> is that properties are saved in the history as values, not as
 names, with the result that repeating a test after loading recompiled code will use the old
 code, unless the property itself makes external calls. Properties saved in the history
 by <a href="#quickcheck-2"><code>quickcheck/2</code></a> and <a href="#quickcheck-3"><code>quickcheck/3</code></a>, though, are saved "by name", and so
 rechecking them will call any newly loaded code.</p></p>

<h3 class="function"><a name="registration-1">registration/1</a></h3>
<div class="spec">
<p><tt>registration(LicenceId) -&gt; any()</tt></p>
</div><p>Create a QuickCheck licence for the current user, using a
 one-time registration identifier. The registration identifier can
 also be supplied the first time QuickCheck is started, via a
 dialogue box.
<p>
<b>NOTE:</b> this <i>replaces</i> your licence file with a new one;
if your licence is currently installed and working, then
<a href="eqc.html#registration-1"><code>eqc:registration/1</code></a> will destroy it! Registering your licence
more than once is only useful if your licence file is corrupt--and
only helps if your licence administrator resets your licence at the
same time. You should therefore <i>only</i> use <a href="eqc.html#registration-1"><code>eqc:registration/1</code></a> when you receive an email from Quviq's licence
server instructing you to do so.
</p>
<p>
 In particular, if you encounter a problem related to the "tamperfree
 seal" on Quviq licence files, then calling <a href="eqc.html#registration-1"><code>eqc:registration/1</code></a> will not help--it will make the problem worse.
</p></p>

<h3 class="function"><a name="reserve-1">reserve/1</a></h3>
<div class="spec">
<p><tt>reserve(Period) -&gt; any()</tt></p>
</div><p><p>Reserve a QuickCheck licence for this machine. Reservations can 
be made for up to seven days; once a licence is reserved, it cannot 
be used on another machine until the reservation has 
expired. Reserving a floating licence can be useful to ensure that 
another user does not begin using it at a critical time, or, since a 
reserved licence can be used without internet access, to prepare a 
laptop for a trip during which internet access will not be 
available.</p>

 <p>Examples: eqc:reserve({3,days}), eqc:reserve({6,hours}), 
eqc:reserve(5). (If the unit, days or hours, is not specified, then 
it defaults to days).</p>

 This call always succeeds, and returns {reserved_until,Time}, where
 Time is the local time the licence is now reserved until.</p>

<h3 class="function"><a name="reserved_until-0">reserved_until/0</a></h3>
<div class="spec">
<p><tt>reserved_until() -&gt; any()</tt></p>
</div><p>The local time that the currently active QuickCheck licence is
 reserved until.</p>

<h3 class="function"><a name="start-0">start/0</a></h3>
<div class="spec">
<p><tt>start() -&gt; any()</tt></p>
</div><p>Equivalent to <a href="#start-1"><tt>start(true)</tt></a>.</p>


<h3 class="function"><a name="start-1">start/1</a></h3>
<div class="spec">
<p><tt>start(Force::bool()) -&gt; pid()</tt></p>
</div><p><p>Starts the QuickCheck server. If it is already running on this 
node, nothing is done.</p>

 Each user can run only one instance of the QuickCheck server at a
 time. If the server is already running on another Erlang node, it
 will be terminated automatically if <tt>Force</tt> is
 <tt>true</tt>. If another instance is running, and <tt>Force</tt> is
 <tt>false</tt>, then the new instance will not start.</p>

<h3 class="function"><a name="stop-0">stop/0</a></h3>
<div class="spec">
<p><tt>stop() -&gt; any()</tt></p>
</div><p>Stops the QuickCheck server.
 QuickCheck properties are tested in the QuickCheck server process, which is
 spawned automatically when quickcheck is first called. Usually there is no
 need to stop the QuickCheck server explicitly, but if a need does arise
 then this function can be used. For example, if the shell process crashes
 and is restarted, then the QuickCheck server should be stopped and restarted
 too, since otherwise the server will crash when it attempts to write to the
 console.</p>

<h3 class="function"><a name="unlock_licence-0">unlock_licence/0</a></h3>
<div class="spec">
<p><tt>unlock_licence() -&gt; any()</tt></p>
</div><p>Unlock the Quviq licence files. The lock protects your licence
 from damage when the files are accessed by concurrent processes.
 However, if a node crashes while holding the lock, then you may need
 to unlock the licence files manually using this function. <b>Make
 certain that no other process actually is running QuickCheck before
 calling this function, otherwise your licence may be corrupted.</b></p>

<h3 class="function"><a name="version-0">version/0</a></h3>
<div class="spec">
<p><tt>version() -&gt; any()</tt></p>
</div><p>Returns the version number of this version of QuickCheck.</p>

<h3 class="function"><a name="watch_shrinking-0">watch_shrinking/0</a></h3>
<div class="spec">
<p><tt>watch_shrinking() -&gt; any()</tt></p>
</div><p>Equivalent to <a href="#watch_shrinking-1"><tt>watch_shrinking(1)</tt></a>.</p>


<h3 class="function"><a name="watch_shrinking-1">watch_shrinking/1</a></h3>
<div class="spec">
<p><tt>watch_shrinking(N::integer()) -&gt; ok</tt></p>
</div><p>Repeats the N-th most recent failed test, like <a href="#recheck-1"><code>recheck/1</code></a>, but displays <i>all</i>
 the test cases explored during shrinking. The test cases are reported in the order they are
 tried, so each Failed test is followed by attempts to shrink it, while each OK test
 (or test skipped because a precondition failed) is
 followed by an alternative way to shrink the last Failed test. The last Failed test displayed
 is the final result of shrinking.</p>

<h3 class="function"><a name="withseed-2">withseed/2</a></h3>
<div class="spec">
<p><tt>withseed(Seed, G) -&gt; any()</tt></p>
</div><p><b>This function is deprecated:</b> Replaced by <a href="#recheck-0"><code>recheck/0</code></a> and <a href="#recheck-1"><code>recheck/1</code></a>. Methods to save test cases
 more permanently are under development. withseed doesn't correctly repeat tests anyway, so
 don't use it.</p>
<p>Run a test case with a given seed.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Sep 22 2009, 19:50:40.</i></p>
</body>
</html>
